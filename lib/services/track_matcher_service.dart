import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:sangeet/models/track.dart';
import 'package:sangeet/models/spotify_models.dart' as plugin;
import 'package:sangeet/services/youtube_service.dart';
import 'package:sangeet/services/ytmusic/yt_music_service.dart';
import 'package:sangeet/services/settings_service.dart';
import 'package:sangeet/services/song_source_preference_service.dart';

/// Regex to match official music content
final _officialMusicRegex = RegExp(
  r"official\s(video|audio|music\svideo|lyric\svideo|visualizer)",
  caseSensitive: false,
);

/// Regex to match Topic channels (auto-generated by YouTube Music)
/// These contain official audio and should be preferred
final _topicChannelRegex = RegExp(
  r"\s*-\s*Topic$",
  caseSensitive: false,
);

/// Regex to match modified/remix versions that should be penalized
/// These are not original audio and should be avoided
final _modifiedVersionRegex = RegExp(
  r"\b(slowed|reverb|remix|8d\s*audio|bass\s*boosted|lofi|lo-fi|sped\s*up|nightcore|chopped|screwed)\b",
  caseSensitive: false,
);

/// Regex to match full/original audio indicators that should be preferred
final _fullAudioRegex = RegExp(
  r"\b(full\s*(audio|song|video)|original|official\s*audio)\b",
  caseSensitive: false,
);

/// Service to match Spotify tracks with audio sources
class TrackMatcherService {
  static final TrackMatcherService _instance = TrackMatcherService._internal();
  factory TrackMatcherService() => _instance;
  TrackMatcherService._internal();

  final YouTubeService _youtubeService = YouTubeService();
  final YtMusicService _ytMusicService = YtMusicService();
  final SongSourcePreferenceService _songSourcePrefService = SongSourcePreferenceService();
  
  // Current music source setting
  MusicSource _musicSource = MusicSource.ytMusic;
  
  /// Set the music source to use
  void setMusicSource(MusicSource source) {
    _musicSource = source;
    print('TrackMatcherService: Using ${source.label} as music source');
  }
  
  // Cache for matched tracks (Spotify ID -> YouTube Track)
  final Map<String, Track> _cache = {};
  
  // Persistent cache key prefix
  static const String _cacheKeyPrefix = 'track_match_';
  bool _cacheInitialized = false;
  
  /// Initialize the persistent cache from SharedPreferences
  Future<void> initCache() async {
    if (_cacheInitialized) return;
    
    final prefs = await SharedPreferences.getInstance();
    final keys = prefs.getKeys().where((k) => k.startsWith(_cacheKeyPrefix));
    
    int loadedCount = 0;
    for (final key in keys) {
      try {
        final spotifyId = key.substring(_cacheKeyPrefix.length);
        final jsonStr = prefs.getString(key);
        if (jsonStr != null) {
          final json = jsonDecode(jsonStr) as Map<String, dynamic>;
          _cache[spotifyId] = Track(
            id: json['youtubeId'] as String,
            title: json['title'] as String,
            artist: json['artist'] as String,
            album: json['album'] as String? ?? '',
            thumbnailUrl: json['thumbnailUrl'] as String?,
            duration: Duration(milliseconds: json['durationMs'] as int? ?? 0),
          );
          loadedCount++;
        }
      } catch (e) {
        print('TrackMatcherService: Error loading cached track: $e');
      }
    }
    
    _cacheInitialized = true;
    print('TrackMatcherService: Loaded $loadedCount cached track matches');
  }
  
  /// Save a track match to persistent cache (public method for external use)
  Future<void> saveMatchToCache(String spotifyId, Track track) async {
    return _saveToCache(spotifyId, track);
  }
  
  /// Save a track match to persistent cache
  Future<void> _saveToCache(String spotifyId, Track track) async {
    // Only save if it's a valid YouTube ID (11 chars)
    if (track.id.length != 11) return;
    
    _cache[spotifyId] = track;
    
    try {
      final prefs = await SharedPreferences.getInstance();
      final json = jsonEncode({
        'youtubeId': track.id,
        'title': track.title,
        'artist': track.artist,
        'album': track.album,
        'thumbnailUrl': track.thumbnailUrl,
        'durationMs': track.duration.inMilliseconds,
      });
      await prefs.setString('$_cacheKeyPrefix$spotifyId', json);
    } catch (e) {
      print('TrackMatcherService: Error saving to cache: $e');
    }
  }
  
  /// Clear the persistent cache
  Future<void> clearCache() async {
    final prefs = await SharedPreferences.getInstance();
    final keys = prefs.getKeys().where((k) => k.startsWith(_cacheKeyPrefix)).toList();
    for (final key in keys) {
      await prefs.remove(key);
    }
    _cache.clear();
    print('TrackMatcherService: Cleared ${keys.length} cached track matches');
  }
  
  /// Get cache statistics
  Map<String, int> getCacheStats() {
    return {
      'memoryCache': _cache.length,
    };
  }
  
  // ============ BACKGROUND PRE-MATCHING SYSTEM ============
  
  // Current playlist session ID - incremented when a new playlist is opened
  int _playlistSessionId = 0;
  
  // Flag to pause background matching when user clicks a song
  bool _backgroundPaused = false;
  
  // Currently running background matching future (for cancellation check)
  int? _activeBackgroundSession;
  
  // Set of Spotify track IDs currently being matched (to avoid duplicate matching)
  final Set<String> _matchingInProgress = {};
  
  // Set of Spotify track IDs that failed matching (for retry with delay)
  final Map<String, DateTime> _failedMatches = {};
  
  // Retry delay for failed matches (5 seconds as requested)
  static const Duration _failedMatchRetryDelay = Duration(seconds: 5);
  
  /// Get current playlist session ID
  int get playlistSessionId => _playlistSessionId;
  
  /// Start background pre-matching for a playlist
  /// Call this when playlist page loads
  void startBackgroundMatching(List<plugin.SpotifyTrack> tracks) {
    // Increment session to cancel any previous background matching
    _playlistSessionId++;
    _backgroundPaused = false;
    _activeBackgroundSession = _playlistSessionId;
    
    print('TrackMatcher: Starting background pre-matching for ${tracks.length} tracks (session $_playlistSessionId)');
    
    // Start matching in background
    _runBackgroundMatching(tracks, _playlistSessionId);
  }
  
  /// Cancel all background matching (call when leaving playlist page)
  void cancelBackgroundMatching() {
    print('TrackMatcher: Cancelling background matching (session $_playlistSessionId)');
    _playlistSessionId++;
    _activeBackgroundSession = null;
    _backgroundPaused = false;
  }
  
  /// Pause background matching temporarily (when user clicks a song)
  void _pauseBackground() {
    _backgroundPaused = true;
    print('TrackMatcher: Background matching paused');
  }
  
  /// Resume background matching
  void _resumeBackground() {
    _backgroundPaused = false;
    print('TrackMatcher: Background matching resumed');
  }
  
  /// Check if a track is already matched (in cache)
  bool isTrackMatched(String spotifyId) {
    return _cache.containsKey(spotifyId);
  }
  
  /// Get a matched track from cache (returns null if not matched yet)
  Track? getMatchedTrack(String spotifyId) {
    return _cache[spotifyId];
  }
  
  /// Match a track with PRIORITY (pauses background, matches this track first)
  /// Returns the matched track immediately if already cached
  Future<Track> matchWithPriority(plugin.SpotifyTrack spotifyTrack) async {
    // Check cache first - instant return if already matched
    if (_cache.containsKey(spotifyTrack.id)) {
      print('TrackMatcher: Cache hit for "${spotifyTrack.name}" - instant playback!');
      return _cache[spotifyTrack.id]!;
    }
    
    // Pause background matching immediately
    _pauseBackground();
    
    try {
      // Wait if this track is already being matched by background (max 3 seconds)
      if (_matchingInProgress.contains(spotifyTrack.id)) {
        print('TrackMatcher: Track "${spotifyTrack.name}" already being matched, waiting...');
        // Poll until it's in cache or timeout (reduced to 3 seconds for faster response)
        for (int i = 0; i < 30; i++) {
          await Future.delayed(const Duration(milliseconds: 100));
          if (_cache.containsKey(spotifyTrack.id)) {
            print('TrackMatcher: Track "${spotifyTrack.name}" matched by background!');
            return _cache[spotifyTrack.id]!;
          }
          if (!_matchingInProgress.contains(spotifyTrack.id)) {
            break; // Background finished but failed, we'll match it ourselves
          }
        }
      }
      
      // Check if this track recently failed - if so, clear the failure to retry immediately for priority
      _failedMatches.remove(spotifyTrack.id);
      
      // Match the track with priority
      print('TrackMatcher: Priority matching "${spotifyTrack.name}"');
      final track = await matchSpotifyPluginTrack(spotifyTrack);
      return track;
    } finally {
      // Resume background matching
      _resumeBackground();
    }
  }
  
  /// Run background matching for all tracks in playlist
  /// Uses parallel matching (2 at a time) to avoid YouTube rate limiting
  Future<void> _runBackgroundMatching(List<plugin.SpotifyTrack> tracks, int sessionId) async {
    const int parallelCount = 2; // Match 2 tracks at a time (3 still causes rate limiting)
    int matchedCount = 0;
    int skippedCount = 0;
    
    for (int i = 0; i < tracks.length; i += parallelCount) {
      // Check if session is still valid
      if (sessionId != _playlistSessionId) {
        print('TrackMatcher: Background session $sessionId cancelled (new session: $_playlistSessionId)');
        return;
      }
      
      // Wait while paused (user clicked a song) - check frequently for fast resume
      while (_backgroundPaused && sessionId == _playlistSessionId) {
        await Future.delayed(const Duration(milliseconds: 30));
      }
      
      // Check session again after pause
      if (sessionId != _playlistSessionId) {
        print('TrackMatcher: Background session $sessionId cancelled after pause');
        return;
      }
      
      // Get batch of tracks to match in parallel
      final endIndex = (i + parallelCount).clamp(0, tracks.length);
      final batch = tracks.sublist(i, endIndex);
      
      // Filter out already cached, in-progress, or recently failed tracks
      final now = DateTime.now();
      final toMatch = batch.where((t) {
        // Skip if already cached
        if (_cache.containsKey(t.id)) {
          skippedCount++;
          return false;
        }
        // Skip if currently being matched
        if (_matchingInProgress.contains(t.id)) return false;
        // Skip if recently failed (wait for retry delay)
        final failedAt = _failedMatches[t.id];
        if (failedAt != null && now.difference(failedAt) < _failedMatchRetryDelay) {
          return false;
        }
        return true;
      }).toList();
      
      if (toMatch.isEmpty) continue;
      
      // Mark all as in progress
      for (final t in toMatch) {
        _matchingInProgress.add(t.id);
      }
      
      // Match in parallel
      final futures = toMatch.map((spotifyTrack) async {
        try {
          await matchSpotifyPluginTrack(spotifyTrack);
          matchedCount++;
          // Clear from failed list on success
          _failedMatches.remove(spotifyTrack.id);
        } catch (e) {
          print('TrackMatcher: Background error for "${spotifyTrack.name}": $e');
          // Mark as failed with timestamp for retry after delay
          _failedMatches[spotifyTrack.id] = DateTime.now();
        }
      });
      
      await Future.wait(futures);
      
      // Remove from in-progress
      for (final t in toMatch) {
        _matchingInProgress.remove(t.id);
      }
      
      // Log progress periodically
      if (matchedCount % 10 == 0 || i + parallelCount >= tracks.length) {
        final total = tracks.length;
        final cached = _cache.length;
        print('TrackMatcher: Background progress: $matchedCount new, $skippedCount already cached, $cached total cached / $total tracks');
      }
      
      // Delay between batches to avoid YouTube rate limiting (reduced for faster matching)
      await Future.delayed(const Duration(milliseconds: 300));
    }
    
    // Retry failed matches after the initial pass
    if (sessionId == _playlistSessionId && _failedMatches.isNotEmpty) {
      print('TrackMatcher: Retrying ${_failedMatches.length} failed matches after delay...');
      await Future.delayed(_failedMatchRetryDelay);
      
      // Only retry if session is still valid
      if (sessionId == _playlistSessionId) {
        final failedTracks = tracks.where((t) => _failedMatches.containsKey(t.id)).toList();
        if (failedTracks.isNotEmpty) {
          await _runBackgroundMatching(failedTracks, sessionId);
        }
      }
    }
    
    if (sessionId == _playlistSessionId) {
      print('TrackMatcher: Background pre-matching complete for session $sessionId ($matchedCount tracks matched)');
    }
  }
  
  // ============ END BACKGROUND PRE-MATCHING SYSTEM ============

  /// Convert a plugin Spotify track to a playable Track
  Future<Track> matchSpotifyPluginTrack(plugin.SpotifyTrack spotifyTrack, {MusicSource? forceSource}) async {
    // Return cached result if available (essential for background pre-matching)
    if (forceSource == null && _cache.containsKey(spotifyTrack.id)) {
      return _cache[spotifyTrack.id]!;
    }
    
    print('TrackMatcherService: Matching "${spotifyTrack.name}" by "${spotifyTrack.artists.map((a) => a.name).join(', ')}"');

    final artistsString = spotifyTrack.artists.map((a) => a.name).join(', ');
    final albumName = spotifyTrack.album.name;
    final imageUrl = spotifyTrack.album.images.isNotEmpty 
        ? spotifyTrack.album.images.first.url 
        : null;
    
    // Check for per-song source preference
    final songPref = _songSourcePrefService.getPreferredSource(spotifyTrack.id);
    final effectiveSource = forceSource ?? songPref ?? _musicSource;
    
    if (songPref != null) {
      print('TrackMatcherService: Using ${effectiveSource.label} (per-song preference) for "${spotifyTrack.name}"');
    }
    
    // Extract clean title without parentheses for better search
    // e.g., "Issue (Mudda Tere Ishq Da)" -> "Issue"
    final cleanTitleMatch = RegExp(r'^(.+?)\s*\(').firstMatch(spotifyTrack.name);
    final cleanTitle = cleanTitleMatch?.group(1)?.trim();
    final primaryArtist = spotifyTrack.artists.isNotEmpty ? spotifyTrack.artists.first.name : '';
    
    // Normalize artist name for search (JA$$A -> jassa)
    final normalizedArtist = _normalizeForSearch(primaryArtist);
    
    // Create alternate title with common Punjabi slang substitutions
    // "Bai" (brother) is often written as "22" in Punjabi songs
    final alternateTitle = _createAlternateTitle(spotifyTrack.name);
    
    // Keep original artist name for searches too (some YouTube results have original spelling)
    final originalArtistClean = primaryArtist.replaceAll(RegExp(r'[^\w\s\$]'), '').trim();
    
    // Try multiple search strategies to find the best match
    List<Track> results = [];
    
    // Strategy 1: Original artist name (preserves special chars like JA$$A)
    final originalQuery = '${spotifyTrack.name} $originalArtistClean';
    print('TrackMatcherService: Searching YouTube for "$originalQuery" (original artist: $primaryArtist)');
    results = await _youtubeService.searchMusic(originalQuery, limit: 20);
    print('TrackMatcherService: YouTube returned ${results.length} results');
    for (final r in results.take(3)) {
      print('  - "${r.title}" by "${r.artist}" [${r.id}]');
    }
    
    // Only try additional strategies if first search didn't find exact match
    // This reduces API calls and avoids rate limiting
    if (results.isEmpty || !_hasExactMatch(results, spotifyTrack)) {
      // Small delay before next API call to avoid rate limiting
      await Future.delayed(const Duration(milliseconds: 200));
      
      // Strategy 2: Try alternate title with slang substitutions (e.g., "Bai" <-> "22")
      if (alternateTitle != null) {
        final alternateQuery = '$alternateTitle $originalArtistClean';
        print('TrackMatcherService: Trying alternate title: "$alternateQuery"');
        final alternateResults = await _youtubeService.searchMusic(alternateQuery, limit: 15);
        for (final r in alternateResults) {
          if (!results.any((existing) => existing.id == r.id)) {
            results.add(r);
          }
        }
      }
      
      // Strategy 3: Try "ARTIST - SONG" format (common YouTube naming convention)
      if (!_hasExactMatch(results, spotifyTrack)) {
        await Future.delayed(const Duration(milliseconds: 200));
        final artistSongQuery = '$originalArtistClean - ${spotifyTrack.name}';
        print('TrackMatcherService: Trying artist-song format: "$artistSongQuery"');
        final artistSongResults = await _youtubeService.searchMusic(artistSongQuery, limit: 10);
        for (final r in artistSongResults) {
          if (!results.any((existing) => existing.id == r.id)) {
            results.add(r);
          }
        }
      }
    }
    
    if (results.isEmpty) {
      // No YouTube results found - throw an error so caller can handle it
      // Don't return a track with Spotify ID as it will fail to stream
      print('TrackMatcherService: No results found for "${spotifyTrack.name}"');
      throw Exception('No YouTube match found for "${spotifyTrack.name}"');
    }

    // Rank results by relevance
    final rankedResults = _rankResults(results, spotifyTrack);
    final bestMatch = rankedResults.first;
    
    print('TrackMatcherService: Best match for "${spotifyTrack.name}" -> "${bestMatch.title}" by "${bestMatch.artist}" [${bestMatch.id}]');
    
    // Create track with Spotify metadata but YouTube ID for playback
    final track = Track(
      id: bestMatch.id, // YouTube ID for playback
      title: spotifyTrack.name, // Use Spotify title (cleaner)
      artist: artistsString,
      album: albumName,
      thumbnailUrl: imageUrl ?? bestMatch.thumbnailUrl,
      duration: Duration(milliseconds: spotifyTrack.durationMs),
    );

    // Cache the result (both memory and persistent)
    await _saveToCache(spotifyTrack.id, track);
    
    return track;
  }

  /// Convert a list of plugin Spotify tracks to playable Tracks
  Future<List<Track>> matchSpotifyPluginTracks(List<plugin.SpotifyTrack> spotifyTracks) async {
    final tracks = <Track>[];
    
    for (final spotifyTrack in spotifyTracks) {
      try {
        final track = await matchSpotifyPluginTrack(spotifyTrack);
        tracks.add(track);
      } catch (e) {
        print('Error matching track ${spotifyTrack.name}: $e');
        final artistsString = spotifyTrack.artists.map((a) => a.name).join(', ');
        final albumName = spotifyTrack.album.name;
        final imageUrl = spotifyTrack.album.images.isNotEmpty 
            ? spotifyTrack.album.images.first.url 
            : null;
        // Add track anyway with Spotify info
        tracks.add(Track(
          id: spotifyTrack.id,
          title: spotifyTrack.name,
          artist: artistsString,
          album: albumName,
          thumbnailUrl: imageUrl,
          duration: Duration(milliseconds: spotifyTrack.durationMs),
        ));
      }
    }
    
    return tracks;
  }

  /// Clean up title for better search
  /// Removes artist names from title if they appear in parentheses
  /// and cleans up common formatting issues
  String _getTitle(String title, {List<String> artists = const []}) {
    // Check if any artist name appears in parentheses
    final match = RegExp(r"(?<=\().+?(?=\))").firstMatch(title)?.group(0);
    final artistInBracket = artists.any((artist) => match?.contains(artist) ?? false);

    if (artistInBracket) {
      title = title.replaceAll(RegExp(r" *\([^)]*\) *"), '');
    }

    // Remove artist names from title
    title = _clearArtistsOfTitle(title, artists);

    // Build final search query: title + artists (with commas replaced by spaces)
    return "$title ${artists.map((e) => e.replaceAll(",", " ")).join(", ")}"
        .replaceAll(RegExp(r"\s*\[[^\]]*]"), ' ')  // Remove brackets content
        .replaceAll(RegExp(r"\sfeat\.|\sft\.", caseSensitive: false), ' ')  // Remove feat./ft.
        .replaceAll(RegExp(r"\s+"), ' ')  // Normalize whitespace
        .trim();
  }

  /// Check if results contain a good match (artist in artist field + title match)
  bool _hasGoodMatch(List<Track> results, plugin.SpotifyTrack track) {
    final artistNames = track.artists.map((a) => a.name.toLowerCase()).toList();
    final trackNameLower = track.name.toLowerCase();
    final cleanTitleMatch = RegExp(r'^(.+?)\s*\(').firstMatch(trackNameLower);
    final cleanTrackName = cleanTitleMatch?.group(1)?.trim() ?? trackNameLower;
    
    for (final result in results) {
      final artistLower = result.artist.toLowerCase();
      final titleLower = result.title.toLowerCase();
      
      // Check if any artist matches in the artist field
      final hasArtistMatch = artistNames.any((a) => artistLower.contains(a));
      // Check if title matches
      final hasTitleMatch = titleLower.contains(trackNameLower) || 
                            titleLower.contains(cleanTrackName);
      
      if (hasArtistMatch && hasTitleMatch) {
        return true;
      }
    }
    return false;
  }

  /// Check if results contain an EXACT match (strict artist + title match)
  /// Used to decide whether to fallback to YouTube
  /// e.g., "Murder" by "Real Boss" should NOT match "Murder Me" by "Real Bosses"
  bool _hasExactMatch(List<Track> results, plugin.SpotifyTrack track) {
    final artistNames = track.artists.map((a) => a.name.toLowerCase()).toList();
    final artistNamesNormalized = track.artists.map((a) => _normalizeForMatching(a.name)).toList();
    final trackNameLower = track.name.toLowerCase();
    final trackNameNormalized = _normalizeForMatching(track.name);
    
    // Extract clean title without parentheses
    final cleanTitleMatch = RegExp(r'^(.+?)\s*\(').firstMatch(trackNameLower);
    final cleanTrackName = cleanTitleMatch?.group(1)?.trim() ?? trackNameLower;
    final cleanTrackNameNormalized = _normalizeForMatching(cleanTrackName);
    
    for (final result in results) {
      final resultArtistLower = result.artist.toLowerCase();
      final resultTitleLower = result.title.toLowerCase();
      final resultArtistNormalized = _normalizeForMatching(result.artist);
      final resultTitleNormalized = _normalizeForMatching(result.title);
      
      // Handle Topic channels (e.g., "JA$$A - Topic" -> "ja$$a")
      final isTopicChannel = _isTopicChannel(resultArtistLower);
      final topicArtistName = isTopicChannel 
          ? _extractArtistFromTopic(resultArtistLower) 
          : resultArtistLower;
      final topicArtistNormalized = _normalizeForMatching(topicArtistName);
      
      // STRICT artist match: artist name must EXACTLY match (word boundary)
      // "Real Boss" should NOT match "Real Bosses"
      bool hasStrictArtistMatch = false;
      for (int i = 0; i < artistNames.length; i++) {
        final artistName = artistNames[i];
        final artistNameNormalized = artistNamesNormalized[i];
        
        // Check for exact word match using regex word boundaries
        final artistRegex = RegExp('\\b${RegExp.escape(artistName)}\\b');
        final artistRegexNormalized = RegExp('\\b${RegExp.escape(artistNameNormalized)}\\b');
        
        // Also check Topic channel artist name
        if (artistRegex.hasMatch(resultArtistLower) ||
            artistRegexNormalized.hasMatch(resultArtistNormalized) ||
            artistRegex.hasMatch(topicArtistName) ||
            artistRegexNormalized.hasMatch(topicArtistNormalized)) {
          hasStrictArtistMatch = true;
          break;
        }
      }
      
      if (!hasStrictArtistMatch) continue;
      
      // STRICT title match: title must contain the track name as exact word
      // "Murder" should NOT match "Murder Me"
      final titleRegex = RegExp('\\b${RegExp.escape(cleanTrackName)}\\b');
      final titleRegexNormalized = RegExp('\\b${RegExp.escape(cleanTrackNameNormalized)}\\b');
      
      final hasStrictTitleMatch = 
          titleRegex.hasMatch(resultTitleLower) ||
          titleRegexNormalized.hasMatch(resultTitleNormalized);
      
      if (!hasStrictTitleMatch) continue;
      
      // Additional check: result title should not have extra words that change meaning
      // e.g., "Murder" should not match "Murder Me" or "Murder Mystery"
      // Check if result title starts with track name or contains it as a word
      final trackWords = cleanTrackName.split(' ');
      final resultWords = resultTitleLower.split(' ');
      
      // Check if all track words appear in result (in order or as prefix)
      bool allWordsMatch = true;
      for (final word in trackWords) {
        if (word.isEmpty) continue;
        if (!resultWords.any((rw) => rw.startsWith(word) || rw == word)) {
          allWordsMatch = false;
          break;
        }
      }
      
      if (hasStrictArtistMatch && hasStrictTitleMatch && allWordsMatch) {
        print('TrackMatcherService: Found exact match: "${result.title}" by "${result.artist}"');
        return true;
      }
    }
    
    return false;
  }

  /// Remove artist names from title
  String _clearArtistsOfTitle(String title, List<String> artists) {
    if (artists.isEmpty) return title;
    return title
        .replaceAll(RegExp(artists.join("|"), caseSensitive: false), "")
        .trim();
  }

  /// Normalize text for matching - handles special characters like $$ in "Ja$$a"
  String _normalizeForMatching(String text) {
    return text
        .toLowerCase()
        .replaceAll(RegExp(r'\$+'), 's') // $$ -> s (Ja$$a -> Jassa)
        .replaceAll(RegExp(r'[^\w\s]'), '') // Remove other special chars
        .replaceAll(RegExp(r'\s+'), ' ') // Normalize whitespace
        .trim();
  }

  /// Normalize text for search queries - handles special characters
  /// Converts $$ to ss for better YouTube search results
  String _normalizeForSearch(String text) {
    return text
        .toLowerCase()
        .replaceAll(RegExp(r'\$+'), 's') // $$ -> s (JA$$A -> jassa)
        .replaceAll(RegExp(r'[^\w\s]'), '') // Remove other special chars
        .replaceAll(RegExp(r'\s+'), ' ') // Normalize whitespace
        .trim();
  }
  
  /// Create alternate title with common Punjabi/Hindi slang substitutions
  /// Handles cases where Spotify and YouTube use different spellings
  String? _createAlternateTitle(String title) {
    String alternate = title;
    bool changed = false;
    
    // Common substitutions in Punjabi songs:
    // "Bai" (brother) <-> "22" (slang for brother, from "do do" meaning two-two)
    // Case insensitive replacements
    if (RegExp(r'\bBai\b', caseSensitive: false).hasMatch(title)) {
      alternate = alternate.replaceAll(RegExp(r'\bBai\b', caseSensitive: false), '22');
      changed = true;
    } else if (RegExp(r'\b22\b').hasMatch(title)) {
      alternate = alternate.replaceAll(RegExp(r'\b22\b'), 'Bai');
      changed = true;
    }
    
    // "Mein/Main" <-> "Mein/Main" (different spellings)
    if (RegExp(r'\bMain\b', caseSensitive: false).hasMatch(title)) {
      alternate = alternate.replaceAll(RegExp(r'\bMain\b', caseSensitive: false), 'Mein');
      changed = true;
    }
    
    return changed ? alternate : null;
  }

  /// Check if artist is from a Topic channel (official YouTube Music auto-generated)
  bool _isTopicChannel(String artist) {
    return _topicChannelRegex.hasMatch(artist);
  }

  /// Extract artist name from Topic channel (e.g., "JA$$A - Topic" -> "JA$$A")
  String _extractArtistFromTopic(String artist) {
    return artist.replaceAll(_topicChannelRegex, '').trim();
  }

  /// Rank search results by relevance
  /// Enhanced with better artist matching to handle same-name artists
  List<Track> _rankResults(List<Track> results, plugin.SpotifyTrack track) {
    final artistNames = track.artists.map((a) => a.name.toLowerCase()).toList();
    final artistNamesNormalized = track.artists.map((a) => _normalizeForMatching(a.name)).toList();
    final trackNameLower = track.name.toLowerCase();
    final trackNameNormalized = _normalizeForMatching(track.name);
    final spotifyDuration = Duration(milliseconds: track.durationMs);
    
    // Extract clean title without parentheses for matching
    // e.g., "Issue (Mudda Tere Ishq Da)" -> "issue"
    final cleanTitleMatch = RegExp(r'^(.+?)\s*\(').firstMatch(trackNameLower);
    final cleanTrackName = cleanTitleMatch?.group(1)?.trim() ?? trackNameLower;
    
    final scored = results.map((sibling) {
      int score = 0;
      final siblingTitleLower = sibling.title.toLowerCase();
      final siblingArtistLower = sibling.artist.toLowerCase();
      final siblingTitleNormalized = _normalizeForMatching(sibling.title);
      final siblingArtistNormalized = _normalizeForMatching(sibling.artist);

      // Check if this is a Topic channel (official YouTube Music auto-generated)
      final isTopicChannel = _isTopicChannel(siblingArtistLower);
      final topicArtistName = isTopicChannel 
          ? _extractArtistFromTopic(siblingArtistLower) 
          : siblingArtistLower;
      final topicArtistNormalized = _normalizeForMatching(topicArtistName);

      // NEW LOGIC: Check artist match in TITLE first (most reliable)
      // e.g., "Bir Rass (Official Audio) Harvi X Veer Sandhu" contains both artists
      int artistsFoundInTitle = 0;
      int artistsFoundInChannel = 0;
      
      for (int i = 0; i < artistNames.length; i++) {
        final artistName = artistNames[i];
        final artistNameNormalized = artistNamesNormalized[i];
        
        // Check if artist appears in the VIDEO TITLE (strongest signal)
        final artistInTitle = siblingTitleLower.contains(artistName) ||
            siblingTitleNormalized.contains(artistNameNormalized);
        if (artistInTitle) {
          artistsFoundInTitle++;
        }
        
        // Check if artist appears in channel/artist field (or Topic channel)
        final artistInChannel = siblingArtistLower.contains(artistName) ||
            siblingArtistNormalized.contains(artistNameNormalized) ||
            topicArtistName.contains(artistName) ||
            topicArtistNormalized.contains(artistNameNormalized);
        if (artistInChannel) {
          artistsFoundInChannel++;
        }
      }
      
      // Scoring based on where artists are found
      bool hasArtistMatch = false;
      
      // BEST: Artist(s) found in title - this is the most reliable match
      // e.g., "Bir Rass (Official Audio) Harvi X Veer Sandhu" by "BANG Music"
      if (artistsFoundInTitle > 0) {
        hasArtistMatch = true;
        score += 35; // Strong bonus for artist in title
        if (artistsFoundInTitle >= artistNames.length) {
          score += 15; // Extra bonus if ALL artists are in title
        }
      }
      
      // GOOD: Artist found in channel name
      if (artistsFoundInChannel > 0) {
        hasArtistMatch = true;
        score += 25; // Good bonus for channel match
        
        // EXTRA BONUS: Topic channels are official and should be preferred
        if (isTopicChannel) {
          score += 20; // Strong preference for Topic channels
          print('TrackMatcherService: Topic channel bonus for "${sibling.artist}"');
        }
      }
      
      // PENALTY: No artist match at all = heavily penalized
      if (!hasArtistMatch) {
        score -= 100;
      }

      // Title matching - use word boundary matching for accuracy
      // "BIR RASS" should NOT match "Mahabir Rass" (partial word match)
      // Split track name into words and check if ALL words appear in result title
      // Also check alternate title (e.g., "Bai" <-> "22" substitution)
      final trackWords = cleanTrackName.split(RegExp(r'\s+')).where((w) => w.isNotEmpty).toList();
      final siblingTitleWords = siblingTitleLower.split(RegExp(r'\s+')).where((w) => w.isNotEmpty).toSet();
      
      // Check alternate title for Punjabi slang substitutions
      final alternateTrackName = _createAlternateTitle(cleanTrackName);
      final alternateTrackWords = alternateTrackName?.toLowerCase().split(RegExp(r'\s+')).where((w) => w.isNotEmpty).toList();
      
      // Check if ALL track words appear as complete words (or word prefixes) in the result
      int matchedWords = 0;
      for (final word in trackWords) {
        // Check for exact word match or word that starts with the track word
        final hasWordMatch = siblingTitleWords.any((tw) => 
            tw == word || tw.startsWith(word) || word.startsWith(tw));
        if (hasWordMatch) {
          matchedWords++;
        }
      }
      
      // Also check alternate title words (for slang substitutions like "Bai" <-> "22")
      int alternateMatchedWords = 0;
      if (alternateTrackWords != null) {
        for (final word in alternateTrackWords) {
          final hasWordMatch = siblingTitleWords.any((tw) => 
              tw == word || tw.startsWith(word) || word.startsWith(tw));
          if (hasWordMatch) {
            alternateMatchedWords++;
          }
        }
      }
      
      // Use the better match ratio between original and alternate title
      final wordMatchRatio = trackWords.isEmpty ? 0.0 : matchedWords / trackWords.length;
      final alternateMatchRatio = alternateTrackWords == null || alternateTrackWords.isEmpty 
          ? 0.0 
          : alternateMatchedWords / alternateTrackWords.length;
      final bestMatchRatio = wordMatchRatio > alternateMatchRatio ? wordMatchRatio : alternateMatchRatio;
      
      if (bestMatchRatio >= 1.0) {
        // All words match - strong bonus
        score += 60; // Increased from 40 - title match is critical
      } else if (bestMatchRatio >= 0.75) {
        // Most words match - good bonus
        score += 30;
      } else if (bestMatchRatio >= 0.5) {
        // Partial match - small bonus
        score += 10;
      } else {
        // Poor match - HEAVY penalty (this is likely a different song)
        // e.g., "Baby This Baby That" when searching for "Tu Mera Bai Main Tera Bai"
        score -= 80; // Increased from 50 - wrong song should be heavily penalized
      }

      // Has official flag
      final hasOfficialFlag = _officialMusicRegex.hasMatch(siblingTitleLower);
      if (hasOfficialFlag) {
        score += 5;
      }
      
      // HEAVY PENALTY for modified versions (slowed, reverb, remix, 8D, bass boosted, etc.)
      // These are not original audio and should be avoided
      final isModifiedVersion = _modifiedVersionRegex.hasMatch(siblingTitleLower);
      if (isModifiedVersion) {
        score -= 100; // Heavy penalty to push these to the bottom
      }
      
      // BONUS for full/original audio indicators
      final isFullAudio = _fullAudioRegex.hasMatch(siblingTitleLower);
      if (isFullAudio) {
        score += 25; // Prefer full audio versions
      }

      // Duration matching - prefer results with similar duration
      final durationDiff = (sibling.duration.inSeconds - spotifyDuration.inSeconds).abs();
      if (durationDiff <= 5) {
        score += 20; // Strong bonus for exact duration match
      } else if (durationDiff <= 15) {
        score += 10; // Good bonus for close duration
      } else if (durationDiff <= 30) {
        score += 5; // Small bonus for reasonable duration
      }
      // No penalty for duration mismatch - just no bonus
      
      // View count bonus - prefer popular/official uploads
      // Higher view counts usually indicate official or popular versions
      final viewCount = sibling.viewCount ?? 0;
      if (viewCount >= 10000000) {
        score += 15; // 10M+ views - very popular
      } else if (viewCount >= 1000000) {
        score += 10; // 1M+ views - popular
      } else if (viewCount >= 100000) {
        score += 5; // 100K+ views - decent
      }
      // No penalty for low views - just no bonus

      return (sibling: sibling, score: score);
    }).toList();

    // Sort by score descending
    scored.sort((a, b) => b.score.compareTo(a.score));
    
    // Log scores for debugging
    for (final item in scored.take(5)) {
      print('TrackMatcherService: Score ${item.score} for "${item.sibling.title}" by "${item.sibling.artist}" [${item.sibling.id}]');
    }

    return scored.map((e) => e.sibling).toList();
  }

  /// Clear cache for a specific song (when source preference changes)
  Future<void> clearCacheForSong(String songId) async {
    _cache.remove(songId);
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('$_cacheKeyPrefix$songId');
    } catch (e) {
      print('TrackMatcherService: Error clearing cache for $songId: $e');
    }
  }
  
  /// Save a manual selection for a song (user chose a specific YouTube video)
  /// This overrides the auto-matched result
  Future<void> saveManualSelection(String spotifyId, Track track) async {
    print('TrackMatcherService: Saving manual selection for $spotifyId -> ${track.id}');
    await _saveToCache(spotifyId, track);
  }
  
  /// Clear cache entries that map to a specific YouTube ID
  /// Used when a YouTube video becomes unplayable (age-restricted, removed, etc.)
  Future<void> clearCacheForYouTubeId(String youtubeId) async {
    // Find all Spotify IDs that map to this YouTube ID
    final spotifyIdsToRemove = <String>[];
    for (final entry in _cache.entries) {
      if (entry.value.id == youtubeId) {
        spotifyIdsToRemove.add(entry.key);
      }
    }
    
    if (spotifyIdsToRemove.isEmpty) {
      print('TrackMatcherService: No cache entries found for YouTube ID $youtubeId');
      return;
    }
    
    // Remove from memory cache and persistent storage
    for (final spotifyId in spotifyIdsToRemove) {
      _cache.remove(spotifyId);
      try {
        final prefs = await SharedPreferences.getInstance();
        await prefs.remove('$_cacheKeyPrefix$spotifyId');
        print('TrackMatcherService: Cleared bad cache entry for Spotify ID $spotifyId (YouTube: $youtubeId)');
      } catch (e) {
        print('TrackMatcherService: Error clearing cache: $e');
      }
    }
  }

  /// Get cache size
  int get cacheSize => _cache.length;
  
  /// Get the song source preference service
  SongSourcePreferenceService get songSourcePrefService => _songSourcePrefService;
}
